// Generated by CoffeeScript 1.3.3
var autoplan, util,
  __slice = [].slice;

util = {
  sum: function(list) {
    return _.reduce(list, (function(sum, n) {
      return sum + n;
    }), 0);
  },
  average: function(list) {
    return this.sum(list) / list.length;
  },
  rotate_arr_to: function(arr, i) {
    return arr.slice(i).concat(arr.slice(0, i));
  },
  partition_by: function(arr, iterator) {
    var arrs, i, k, lastv, newv, suba, x, _i, _len;
    if (iterator == null) {
      iterator = _.identity;
    }
    if (_.isString(iterator)) {
      k = iterator;
      iterator = function(x) {
        return x[k];
      };
    }
    arrs = [];
    suba = [];
    lastv = null;
    for (i = _i = 0, _len = arr.length; _i < _len; i = ++_i) {
      x = arr[i];
      newv = iterator(x);
      if (i === 0 || lastv !== newv) {
        suba = [x];
        arrs.push(suba);
      } else {
        suba.push(x);
      }
      lastv = newv;
    }
    return arrs;
  },
  uniq_stable: function(arr, iterator) {
    var k, narr, visited;
    if (iterator == null) {
      iterator = _.identity;
    }
    if (_.isString(iterator)) {
      k = iterator;
      iterator = function(x) {
        return x[k];
      };
    }
    visited = [];
    narr = [];
    _.each(arr, function(e) {
      var new_e;
      new_e = iterator(e);
      if (!_.contains(visited, new_e)) {
        visited.push(new_e);
        return narr.push(e);
      }
    });
    return narr;
  },
  rejectFirst: function(list, iterator) {
    var e, i, new_list, _i, _len;
    new_list = list;
    for (i = _i = 0, _len = list.length; _i < _len; i = ++_i) {
      e = list[i];
      if (iterator(e)) {
        new_list = list.slice(0, i).concat(list.slice(i + 1));
        break;
      }
    }
    return new_list;
  },
  toPrecisionFixed: function(num, prec) {
    var absv, d, e, l, sign;
    if (isNaN(num)) {
      return "NaN";
    }
    absv = num < 0 ? -num : num;
    sign = num < 0 ? "-" : "";
    if (absv === 0) {
      e = "0.";
      while (prec--) {
        e += "0";
      }
      return e;
    }
    d = Math.ceil(Math.log(absv) * Math.LOG10E);
    e = String(Math.round(absv * Math.pow(10, prec - d)));
    if (d > 0) {
      l = d - e.length;
      while (l-- > 0) {
        e += "0";
      }
      if (d < e.length) {
        e = e.slice(0, d) + "." + e.slice(d);
      }
    } else {
      while (d++ < 0) {
        e = "0" + e;
      }
      e = "0." + e;
    }
    return sign + e;
  },
  toReadableHour: function(seconds) {
    return (seconds / 3600).toFixed(2);
  },
  toReadableDistance: function(meters) {
    if (meters < 1000) {
      return "" + meters + " 米";
    } else {
      return "" + ((meters / 1000).toFixed(2)) + " 千米";
    }
  },
  toReadableDuration: function(seconds) {
    if (seconds < 3600) {
      return "" + (parseInt(seconds / 60)) + " 分钟";
    } else {
      return "" + ((seconds / 3600).toFixed(2)) + " 小时";
    }
  }
};

autoplan = {
  HOTEL_COVER_RADIUS: 40,
  AREA_DISTANCE_THRESHOLD: 50,
  dirRenderers: [],
  partition_days: function(city, durations, distances) {
    var day, days, dur_acc, maxSeconds, maxSeconds2, meters_threshold, zones;
    zones = city.zones;
    days = [];
    dur_acc = 0;
    maxSeconds = 8 * 3600;
    maxSeconds2 = 10 * 3600;
    meters_threshold = 5000;
    day = null;
    _.each(zones, function(zone, i) {
      zone.index = i;
      return _.each(zone.points, function(p) {
        return p.ac.area_index = zone.area_index;
      });
    });
    _.each(zones, function(zone, i) {
      var dur, stay_hours;
      stay_hours = zone.stay_hours;
      dur = (i === 0 ? 0 : durations[i - 1]);
      zone.duration = dur;
      dur_acc += dur + stay_hours * 3600;
      if (i === 0 || dur_acc > maxSeconds2 || (dur_acc > maxSeconds && distances[i - 1] > meters_threshold)) {
        dur_acc = stay_hours * 3600;
        day = {
          zones: [zone],
          duration: dur_acc
        };
        return days.push(day);
      } else {
        day.zones.push(zone);
        return day.duration = dur_acc;
      }
    });
    days = this.re_partition_days(days, durations);
    _.each(days, function(day) {
      return _.extend(day, {
        acs: _.flatten(_.map(day.zones, function(zone, i) {
          if (i === 0) {
            zone.duration = 0;
          }
          return _.map(zone.points, function(p) {
            return p.ac;
          });
        })),
        start_area: day.zones[0].area,
        end_area: _.last(day.zones).area
      });
    });
    _.each(days, function(day, i) {
      var durs, names, zone_logs;
      zone_logs = _.map(day.zones, function(zone) {
        var durs, names;
        names = _.map(zone.points, function(p) {
          return "" + (p.ac.get_place().name) + "(" + (p.ac.get_stay_hours()) + ")";
        });
        durs = ["" + (util.toReadableHour(zone.duration)), zone.stay_hours];
        return {
          name: names.join(','),
          dur: durs.join('+')
        };
      });
      names = _.map(zone_logs, function(zl) {
        return zl.name;
      });
      durs = _.map(zone_logs, function(zl) {
        return zl.dur;
      });
      return console.log("" + city.name + " day " + i + ", " + (util.toReadableHour(day.duration)) + " = " + (durs.join(' + ')) + ": " + (names.join(' -> ')));
    });
    return days;
  },
  re_partition_days: function(days, durations) {
    var calc_zones_duration;
    calc_zones_duration = function(zones) {
      return util.sum(_.map(zones, function(zone, i) {
        return zone.stay_hours * 3600 + (i === 0 ? 0 : durations[zone.index - 1]);
      }));
    };
    _.each(days, function(day, i) {
      var d, dur0, dur1, last_day, min_d, min_day_pair, zones0, zones1, _i, _ref;
      if (i === 0) {
        return;
      }
      last_day = days[i - 1];
      dur0 = last_day.duration;
      dur1 = day.duration;
      if (dur1 >= dur0) {
        return;
      }
      min_d = dur0 - dur1;
      min_day_pair = [last_day, day];
      for (i = _i = _ref = last_day.zones.length - 1; _ref <= 0 ? _i < 0 : _i > 0; i = _ref <= 0 ? ++_i : --_i) {
        zones0 = last_day.zones.slice(0, i);
        zones1 = last_day.zones.slice(i).concat(day.zones);
        dur0 = calc_zones_duration(zones0);
        dur1 = calc_zones_duration(zones1);
        d = Math.abs(dur1 - dur0);
        if (min_d > d) {
          min_d = d;
          min_day_pair = [
            {
              zones: zones0,
              duration: dur0
            }, {
              zones: zones1,
              duration: dur1
            }
          ];
        } else {
          break;
        }
      }
      _.extend(last_day, min_day_pair[0]);
      return _.extend(day, min_day_pair[1]);
    });
    return days;
  },
  reset_days: function(days, remaining_hotel_acs) {
    var day_models;
    editor.schedule.each(function(day) {
      return day.reset_activities([], 2);
    });
    day_models = _.map(days, function(d, i) {
      var day;
      day = editor.schedule.getDay(i, true);
      day.reset_activities(d.acs, 2);
      return day;
    });
    editor.schedule.reset(day_models, {
      silent: true
    });
    editor.info.reset_all_acs();
    _.each(remaining_hotel_acs, function(ac) {
      return editor.wishlist.add_place(ac.get_place(), {
        silent: true
      });
    });
    editor.wishlist.classify_wps();
    editor.info.save_detail();
    editor.schedule_view.addAll();
    editor.wishlist_view.render();
    return editor.change_day_city(0);
  },
  center_location: function(locations) {
    var loc, tlat, tlgt, _i, _len;
    tlat = 0;
    tlgt = 0;
    for (_i = 0, _len = locations.length; _i < _len; _i++) {
      loc = locations[_i];
      tlat += loc.lat;
      tlgt += loc.lgt;
    }
    return new LatLgt(tlat / locations.length, tlgt / locations.length);
  },
  get_nearest_pair: function(points0, points1) {
    var d, i, j, min_dist, nearest_pair, p0, p1, _i, _j, _len, _len1;
    nearest_pair = [0, 0];
    min_dist = 100000000;
    for (i = _i = 0, _len = points0.length; _i < _len; i = ++_i) {
      p0 = points0[i];
      for (j = _j = 0, _len1 = points1.length; _j < _len1; j = ++_j) {
        p1 = points1[j];
        d = p0.location.distanceTo(p1.location);
        if (min_dist > d) {
          nearest_pair = [i, j];
          min_dist = d;
        }
      }
    }
    return nearest_pair;
  },
  get_nearest_point: function(point, points1) {
    var d, i, min_dist, nearest_i, p1, _i, _len;
    min_dist = 10000000;
    nearest_i = 0;
    for (i = _i = 0, _len = points1.length; _i < _len; i = ++_i) {
      p1 = points1[i];
      d = point.location.distanceTo(p1.location);
      if (min_dist > d) {
        min_dist = d;
        nearest_i = i;
      }
    }
    return nearest_i;
  },
  plan_clusters2: function(city, points, clusters2) {
    var ac, area, areai, areas, city_location, cluster, clusteri, clusters, i, j, last_point, me, min_i, names, nearest_i, p, start_i, stay_hours, sub_names, tsp, x, z, zone, zone_points, zones, _i, _len;
    for (clusteri = _i = 0, _len = clusters2.length; _i < _len; clusteri = ++_i) {
      clusters = clusters2[clusteri];
      names = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = clusters.length; _j < _len1; _j++) {
          cluster = clusters[_j];
          sub_names = (function() {
            var _k, _len2, _results1;
            _results1 = [];
            for (_k = 0, _len2 = cluster.length; _k < _len2; _k++) {
              i = cluster[_k];
              ac = points[i].ac;
              _results1.push("" + (ac.get_place().name) + "(" + (ac.get_stay_hours()) + ")");
            }
            return _results1;
          })();
          _results.push(sub_names.join(','));
        }
        return _results;
      })();
      console.log("" + city.name + " area " + clusteri, names.join(' - '));
    }
    me = this;
    tsp = this.tsp2;
    areas = (function() {
      var _j, _k, _len1, _len2, _ref, _ref1, _results;
      _results = [];
      for (areai = _j = 0, _len1 = clusters2.length; _j < _len1; areai = ++_j) {
        clusters = clusters2[areai];
        area = {};
        zones = (function() {
          var _k, _len2, _results1;
          _results1 = [];
          for (_k = 0, _len2 = clusters.length; _k < _len2; _k++) {
            cluster = clusters[_k];
            zone_points = (function() {
              var _l, _len3, _results2;
              _results2 = [];
              for (_l = 0, _len3 = cluster.length; _l < _len3; _l++) {
                i = cluster[_l];
                _results2.push(points[i]);
              }
              return _results2;
            })();
            zone_points = tsp.solveRoundTrip(zone_points);
            _results1.push(zone = {
              city_id: city.id,
              location: this.center_location((function() {
                var _l, _len3, _results2;
                _results2 = [];
                for (_l = 0, _len3 = zone_points.length; _l < _len3; _l++) {
                  p = zone_points[_l];
                  _results2.push(p.location);
                }
                return _results2;
              })()),
              stay_hours: util.sum((function() {
                var _l, _len3, _results2;
                _results2 = [];
                for (_l = 0, _len3 = zone_points.length; _l < _len3; _l++) {
                  p = zone_points[_l];
                  stay_hours = parseFloat(p.ac.get_place().stay_hours);
                  _results2.push(stay_hours = isNaN(stay_hours) ? 2 : stay_hours);
                }
                return _results2;
              })()),
              points: zone_points,
              area_index: areai,
              area: area
            });
          }
          return _results1;
        }).call(this);
        zones = tsp.solveRoundTrip(zones);
        if (zones.length > 1) {
          _ref = me.get_nearest_pair(zones[0].points, zones[1].points), start_i = _ref[0], j = _ref[1];
          zones[0].points = util.rotate_arr_to(zones[0].points, start_i);
          _ref1 = zones.slice(1);
          for (i = _k = 0, _len2 = _ref1.length; _k < _len2; i = ++_k) {
            zone = _ref1[i];
            last_point = _.last(zones[i].points);
            nearest_i = me.get_nearest_point(last_point, zone.points);
            zone.points = util.rotate_arr_to(zone.points, nearest_i);
          }
        }
        _results.push(_.extend(area, {
          city_id: city.id,
          location: me.center_location((function() {
            var _l, _len3, _results1;
            _results1 = [];
            for (_l = 0, _len3 = zones.length; _l < _len3; _l++) {
              z = zones[_l];
              _results1.push(z.location);
            }
            return _results1;
          })()),
          zones: zones,
          points: _.flatten([
            (function() {
              var _l, _len3, _results1;
              _results1 = [];
              for (_l = 0, _len3 = zones.length; _l < _len3; _l++) {
                x = zones[_l];
                _results1.push(x.points);
              }
              return _results1;
            })()
          ])
        }));
      }
      return _results;
    }).call(this);
    areas = tsp.solveRoundTrip(areas);
    city_location = new LatLgt(city.lat, city.lgt);
    min_i = _.chain(areas).map(function(area, i) {
      return {
        i: i,
        area: area
      };
    }).min(function(x) {
      return x.area.location.distanceTo(city_location);
    }).value().i;
    areas = util.rotate_arr_to(areas, min_i);
    return areas;
  },
  get_city_promise: function(city_id) {
    return get_cities_promise([city_id]).pipe(function(cities) {
      return cities[0];
    });
  },
  get_cities_promise: function(city_ids) {
    var deferred, do_resolve, me, missing_ids;
    me = this;
    deferred = $.Deferred();
    do_resolve = function() {
      var cities, id;
      cities = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = city_ids.length; _i < _len; _i++) {
          id = city_ids[_i];
          _results.push(me.id2city[id]);
        }
        return _results;
      })();
      return deferred.resolve(cities);
    };
    this.id2city = this.id2city || {};
    missing_ids = _.difference(city_ids, _.keys(this.id2city));
    if (missing_ids.length > 0) {
      $.getJSON("/api/cities?ids=" + (city_ids.join(',')), function(res) {
        var city, _i, _len, _ref;
        _ref = res.items;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          city = _ref[_i];
          me.id2city[city.id] = city;
        }
        return do_resolve();
      });
    } else {
      do_resolve();
    }
    return deferred;
  },
  plan_tsp_promise: function(acs) {
    var ac, cid2points, city_ids, me, points, tsp, tsp_defer;
    me = this;
    tsp_defer = $.Deferred();
    tsp = this.tsp2 = this.tsp2 || new TspSolver();
    points = _.map(acs, function(ac) {
      var place, point;
      place = ac.get_place();
      return point = {
        location: new LatLgt(place.glat, place.glgt),
        ac: ac
      };
    });
    city_ids = _.uniq((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = acs.length; _i < _len; _i++) {
        ac = acs[_i];
        _results.push(ac.get_place().city_id);
      }
      return _results;
    })());
    cid2points = _.groupBy(points, function(p) {
      return p.ac.get_place().city_id;
    });
    me.get_cities_promise(city_ids).then(function(raw_cities) {
      var c, city_points, jqXHRs, lgtlats, p;
      jqXHRs = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = raw_cities.length; _i < _len; _i++) {
          c = raw_cities[_i];
          city_points = cid2points[c.id];
          lgtlats = (function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = city_points.length; _j < _len1; _j++) {
              p = city_points[_j];
              _results1.push([p.ac.get_place().glgt, p.ac.get_place().glat]);
            }
            return _results1;
          })();
          _results.push($.ajax({
            type: 'POST',
            url: "/cluster2?threshold=30,1",
            data: JSON.stringify(lgtlats),
            dataType: 'json'
          }));
        }
        return _results;
      })();
      return $.when.apply(null, jqXHRs).done(function() {
        var all_args, areas, args, cities, city, clusters2, i, x;
        all_args = jqXHRs.length > 1 ? arguments : [arguments];
        cities = (function() {
          var _i, _len, _results;
          _results = [];
          for (i = _i = 0, _len = all_args.length; _i < _len; i = ++_i) {
            args = all_args[i];
            clusters2 = args[0];
            c = raw_cities[i];
            city_points = cid2points[c.id];
            areas = me.plan_clusters2(c, city_points, clusters2);
            _results.push(city = {
              id: c.id,
              name: c.name,
              location: new LatLgt(c.glat, c.glgt),
              areas: areas,
              zones: _.flatten([
                (function() {
                  var _j, _len1, _results1;
                  _results1 = [];
                  for (_j = 0, _len1 = areas.length; _j < _len1; _j++) {
                    x = areas[_j];
                    _results1.push(x.zones);
                  }
                  return _results1;
                })()
              ]),
              points: _.flatten([
                (function() {
                  var _j, _len1, _results1;
                  _results1 = [];
                  for (_j = 0, _len1 = areas.length; _j < _len1; _j++) {
                    x = areas[_j];
                    _results1.push(x.points);
                  }
                  return _results1;
                })()
              ])
            });
          }
          return _results;
        })();
        cities = tsp.solveRoundTrip(cities, false);
        return tsp_defer.resolve(cities);
      }).fail(function(err) {
        console.error("Fail to cluster " + err);
        return tsp_defer.reject(err);
      });
    });
    return tsp_defer;
  },
  get_recommended_hotel_promise: function(location, city_id) {
    return $.get("/api/recommend/hotel", {
      lat: location.lat,
      lgt: location.lgt,
      city_id: city_id,
      r: 5
    }).pipe(function(hotel) {
      hotel.auto = true;
      return hotel;
    });
  },
  get_place_location: function(place) {
    return place.location || (place.location = new LatLgt(place.lat, place.lgt));
  },
  match_recommend_hotels_promise: function(cities, hotels) {
    var areas, find_nearest_hotel, find_nearest_hotels, hotel_defers, hotels_defer, me;
    me = this;
    hotels_defer = $.Deferred();
    find_nearest_hotel = function(area, hotels) {
      var city_hotels, nearest_hotel;
      city_hotels = _.filter(hotels, function(h) {
        return h.city_id === area.city_id;
      });
      nearest_hotel = _.min(city_hotels, function(hotel) {
        return me.placeDistance(hotel, area);
      });
      return nearest_hotel != null ? nearest_hotel : null;
    };
    find_nearest_hotels = function(areas, hotels) {
      var areas_hotels;
      return areas_hotels = _.map(areas, function(area) {
        return find_nearest_hotel(area, hotels);
      });
    };
    hotels = _.uniq(hotels, false, function(h) {
      return h.id;
    });
    hotels = _.reject(hotels, function(h) {
      return h.auto;
    });
    _.each(hotels, function(h) {
      return h.location = me.get_place_location(h);
    });
    areas = _.flatten(_.pluck(cities, 'areas'));
    hotel_defers = _.map(areas, function(area) {
      var nearest_hotel;
      area.hotels = [];
      nearest_hotel = find_nearest_hotel(area, hotels);
      if (!nearest_hotel) {
        return me.get_recommended_hotel_promise(area.location, area.city_id);
      } else {
        if (me.placeDistance(nearest_hotel, area) > me.HOTEL_COVER_RADIUS) {
          area.hotels.push(nearest_hotel);
          return me.get_recommended_hotel_promise(area.location, area.city_id);
        } else {
          return nearest_hotel;
        }
      }
    });
    $.when.apply($, hotel_defers).done(function() {
      var hotel_names, hotels, id2hotels;
      hotels = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      id2hotels = _.groupBy(_.sortBy(hotels, function(h) {
        if (h.auto) {
          return 1;
        } else {
          return 0;
        }
      }), 'id');
      hotels = _.map(hotels, function(h) {
        return id2hotels[h.id][0];
      });
      hotel_names = [];
      _.each(hotels, function(h, i) {
        var am, names;
        areas[i].hotels.push(h);
        am = h.auto ? 'a' : 'm';
        names = _.map(areas[i].hotels, function(h) {
          return "" + h.name + "(" + h.id + "," + am + "," + (me.placeDistance(h, areas[i]).toFixed(1)) + ")";
        });
        return hotel_names.push(names.join(','));
      });
      console.log("area hotels: " + (hotel_names.join('; ')));
      return hotels_defer.resolve(cities);
    }).fail(function(err) {
      return hotels_defer.reject(err);
    });
    return hotels_defer;
  },
  partition_all_days_promise: function(cities) {
    var city, days_defer, me, routes_deferreds;
    me = this;
    days_defer = $.Deferred();
    routes_deferreds = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = cities.length; _i < _len; _i++) {
        city = cities[_i];
        _results.push(editor.gs.get_routes_promise(city.zones, google.maps.TravelMode.DRIVING));
      }
      return _results;
    })();
    $.when.apply($, routes_deferreds).fail(function(err) {
      return days_defer.reject(err);
    }).done(function() {
      var args, days, i, _days, _i, _len;
      days = [];
      for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {
        args = arguments[i];
        city = cities[i];
        _days = me.partition_days(city, args.durations, args.distances);
        days = days.concat(_days);
      }
      return days_defer.resolve(days);
    });
    return days_defer;
  },
  placeDistance: function(p1, p2) {
    return this.get_place_location(p1).distanceTo(this.get_place_location(p2));
  },
  add_hotel_promise: function(days, hotel_acs0) {
    /*
        area.manual_hotel - user chosen nearest hotel
        area.matched_auto_hotel - matched not-so-near recommended hotel
        area.auto_hotel - recommended nearby hotel
        each area has one or two hotel candidates (area.hotels)
        choose day starting hotel
            first day - choose starting area's first candidate hotel
            other day - last day's ending hotel
        choose day ending hotel
            starting hotel
            ending area's first candidate
            next day's starting area's first candidate
    
            first day
    
            other day
                == # the same area with prev and next day
                    starting hotel
                =!  # the same area with prev day
                !!
                    if start_hotel in end_area
                        start_hotel
                    else if not next_day or (next_day !! and distance(end_area, next_day.start_area) < 40)
                      # starting hotel
                      ending area's first candidate
                    else
                      next day's starting area's first candidate
                !=
                    end_area.first_candidate
    */

    var defer, do_add_hotels, get_cross_day_flag, me, new_hotel_acs, new_hotels;
    defer = $.Deferred();
    me = this;
    do_add_hotels = function(new_hotel_acs) {
      var hotel2acs, remaining_hotel_acs;
      hotel2acs = _.groupBy(hotel_acs0.concat(new_hotel_acs), function(ac) {
        return ac.get('place_id');
      });
      _.each(days, function(day) {
        var day_acs;
        day_acs = _.map([day.start_hotel, day.end_hotel], function(hotel) {
          if (!hotel) {
            return null;
          }
          if (!hotel2acs[hotel.id]) {
            console.log("can not find ac for hotel", hotel, hotel2acs);
            return null;
          }
          return hotel2acs[hotel.id].pop();
        });
        if (day_acs[0]) {
          day.acs.unshift(day_acs[0]);
        }
        if (day_acs[1]) {
          return day.acs.push(day_acs[1]);
        }
      });
      remaining_hotel_acs = _.flatten(_.values(hotel2acs));
      return defer.resolve(days, remaining_hotel_acs);
    };
    get_cross_day_flag = function(day1, day2) {
      if ((day1 != null ? day1.end_area : void 0) === (day2 != null ? day2.start_area : void 0)) {
        return '=';
      } else {
        return '!';
      }
    };
    _.each(days, function(day, i) {
      var flag, flag1, next_day, next_next_day, prev_day, start_hotel;
      if (i > 0) {
        prev_day = days[i - 1];
      }
      if (i < days.length - 1) {
        next_day = days[i + 1];
      }
      flag = get_cross_day_flag(prev_day, day) + get_cross_day_flag(day, next_day);
      start_hotel = day.start_area.city_id === (prev_day != null ? prev_day.end_area.city_id : void 0) ? (prev_day != null ? prev_day.end_hotel : void 0) || day.start_area.hotels[0] : day.start_area.hotels[0];
      day.start_hotel = start_hotel;
      return day.end_hotel = (function() {
        switch (flag) {
          case '==':
            return start_hotel;
          case '=!':
          case '!!':
            if (start_hotel === day.end_area.hotels[0]) {
              return start_hotel;
            } else {
              if (i < days.length - 2) {
                next_next_day = days[i + 2];
              }
              flag1 = get_cross_day_flag(next_day, next_next_day);
              if (!next_day || day.end_area.city_id !== next_day.start_area.city_id || (flag1 === '!' && me.placeDistance(day.end_area, next_day.start_area) < me.AREA_DISTANCE_THRESHOLD)) {
                return day.end_area.hotels[0];
              } else {
                return next_day.start_area.hotels[0];
              }
            }
            break;
          case '!=':
            return day.end_area.hotels[0];
        }
      })();
    });
    new_hotels = _.compact(_.flatten(_.map(days, function(day) {
      return [day.start_hotel, day.end_hotel];
    })));
    _.each(hotel_acs0, function(ac) {
      return new_hotels = util.rejectFirst(new_hotels, function(h) {
        return h.id === ac.get('place_id');
      });
    });
    new_hotel_acs = _.map(new_hotels, function(h) {
      return editor.create_ac_by_place(h);
    });
    do_add_hotels(new_hotel_acs);
    return defer;
  },
  sync_acs_promise: function(days, remaining_hotel_acs) {
    var new_acs, new_core_acs_attrs, sync_defer, _done;
    sync_defer = $.Deferred();
    new_acs = _.map(days, function(day) {
      return _.filter(day.acs, function(ac) {
        return ac.isNew();
      });
    });
    new_acs = _.flatten(new_acs);
    _done = function(acs_attrs) {
      _.each(new_acs, function(ac, i) {
        return ac.set(acs_attrs[i], {
          silent: true
        });
      });
      _.each(remaining_hotel_acs, function(ac) {
        return ac.destroy({
          silent: true
        });
      });
      return sync_defer.resolve(days, remaining_hotel_acs);
    };
    if (new_acs.length) {
      new_core_acs_attrs = _.map(new_acs, function(ac) {
        return {
          place_id: ac.get('place_id'),
          place_type: ac.get('place_type'),
          auto: ac.get('auto')
        };
      });
      editor.ajax_save("batch create " + new_acs.length + " activities", {
        type: 'POST',
        url: "/api/plans/" + editor.info.plan_id + "/activities/batch",
        data: JSON.stringify(new_core_acs_attrs)
      }).fail(function(err) {
        return sync_defer.reject(err);
      }).done(function(acs_attrs) {
        return _done(acs_attrs);
      });
    } else {
      _done([]);
    }
    return sync_defer;
  },
  split_acs: function(acs) {
    var hotel_acs, non_hotel_acs;
    non_hotel_acs = _.filter(acs, function(ac) {
      return ac.get("place_type") !== "hotel";
    });
    hotel_acs = _.difference(acs, non_hotel_acs);
    return [hotel_acs, non_hotel_acs];
  },
  plan: function(acs, cluster_times) {
    var hotel_acs, me, non_hotel_acs, _ref;
    me = this;
    _ref = me.split_acs(acs), hotel_acs = _ref[0], non_hotel_acs = _ref[1];
    console.log("optimizing starts: do tsp for " + hotel_acs.length + " + " + non_hotel_acs.length + " acs (hotel + other)");
    return me.plan_tsp_promise(non_hotel_acs).pipe(function(cities) {
      var hotels;
      console.log('optimizing: match/recommend hotel for each area', cities);
      hotels = _.map(hotel_acs, function(ac) {
        var p;
        p = ac.get_place();
        p.auto = ac.get('auto') || false;
        return p;
      });
      return me.match_recommend_hotels_promise(cities, hotels).fail(function(err) {
        return 'optimizing: Fail to match/recommend hotel';
      });
    }).pipe(function(cities) {
      console.log('optimizing: partition days for all cities', cities);
      return me.partition_all_days_promise(cities).fail(function() {
        return console.log('optimizing: Fail to partition days');
      });
    }).pipe(function(days) {
      console.log('optimizing: arrange hotel for each day', days);
      return me.add_hotel_promise(days, hotel_acs).fail(function() {
        return 'optimizing: Fail to arrange hotel';
      });
    }).pipe(function(days, remaining_hotel_acs) {
      console.log('optimizing: save new created acs and destroy redundant hotel acs', days, remaining_hotel_acs);
      return me.sync_acs_promise(days, remaining_hotel_acs).fail(function() {
        return 'optimizing: fail to sync acs';
      });
    }).done(function(days, remaining_hotel_acs) {
      console.log('optimizing: reset plan schedule', days, remaining_hotel_acs);
      return me.reset_days(days, remaining_hotel_acs);
    });
  },
  plan_day_promise: function(acs) {
    var hotel_acs, me, non_hotel_acs, plan_defer, _ref;
    me = this;
    plan_defer = $.Deferred();
    _ref = me.split_acs(acs), hotel_acs = _ref[0], non_hotel_acs = _ref[1];
    console.log("optimizing day starts: do tsp for " + hotel_acs.length + " + " + non_hotel_acs.length + " acs (hotel + other)");
    me.plan_tsp_promise(non_hotel_acs).fail(function(err) {
      return plan_defer.reject(err);
    }).done(function(cities) {
      var new_acs, points;
      points = _.flatten(_.pluck(cities, 'points'));
      new_acs = _.pluck(points, 'ac');
      if (hotel_acs.length > 0) {
        new_acs.unshift(hotel_acs[0]);
      }
      new_acs = new_acs.concat(hotel_acs.slice(1));
      return plan_defer.resolve(new_acs);
    });
    return plan_defer;
  }
};
